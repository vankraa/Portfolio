# Project 01

The script in *project_analyze.sh* is designed to compile an error log for Python and Haskell files
only with the file extensions **.hs** and **.py**.

## Features

1. 5.3: Compile error log
  - Chosen with the -cef flag from the command line or from user input
2. 5.7: Find last working file
  - Chosen with the -lwf flag from the command line or from user input 
3. Custom: File initializer with author data and/or shebang line
  - Chosen with the -fi flag from the command line or from user input 

## 5.3: Compile Error Log

### Description

Finds Haskell and Python files in the repo that fail to compile and lists them in a file compile_fail.log.

Initializes by displaying the following instructions for the user and adding *CS1XA3 Repository Error Log* to the **compile_fail.log** file:

- "To begin a new error log for Python and Haskell files, type **'n'**"
- "To read the contents of the current error log, type **'r'**" 
- "To see these instructions again enter **'help'**"
- "Otherwise, type **'exit'** to quit." 

Command | Action
--------|--------
**n**   | Runs the error compiler, deleting any previous error log and parsing the whole repository for .hs and .py files.
**r**   | Displays the contents of the current error log.
**help** | Displays the instructions again.
**exit** | Stops the program.

### Details

An infinite loop begins with a variable awaiting the following user inputs that determines the action carried out by the error logger.

#### n

Any file entitled **compile_fail.log** is deleted in order to create a fresh log. Then the **CS1XA3** directory and all subdirectories is searched for **.hs** files before compiling them using ghc.
The issue of excess files being generated by the ghc compiler is addressed with the -fno-code flag.The same search/compile method is used for **.py** files using `python3 -B` to compile with
no extra **.pyc** files. The stderr output is displayed for the user, but the script uses only the flag from the failed compilation and writes the file name and directory to **compile_fail.log**
for each **.hs** and **.py** file found.

#### r

A simple check to see if a file titled **compile_fail.log** exists and stdout from the `cat` command is displayed.

#### help

Several `echo` statements displaying instructions.

#### exit

The `break` command stops the infinite loop waiting for input from the user.

## 5.7: Find Last Working File

### Description

A file given by user input is found and the last working version is merged to the specified branch. If no working version exists, the most current version is kept.

### Details

Upon selecting the find last working file feature, the user is prompted to choose the branch they would wish to restore a file to, followed by the file to restore.

Any uncommitted actions are stashed before turning the list of previous commits into an array.

The unser input file is then checked if it a **.hs** or **.py** file and is compiled to determine if it is currently working or not. If not, a for loop iterates over each past commit performing
three checks:

1. Does the file exist on this commit
2. Does the file compile with no errors?
3. Is this the initial commit where the repo was created?

Upon successfully passing **1. + 2.**, the following code is executed to restore the file from the commit being parsed to the specified branch at the most recent commit,
and to delete the temporary branch created in the process:

```bash
git checkout $brn
git checkout tmpbranch $path
git add $path
echo ""
git commit -m"Restoring $file from commit $hash"
echo ""
git branch -D tmpbranch
break
````

If the file does not exist on this commit, or the file does not compile and the commit is determined to be the *Initial Commit,* the user is informed of the search failure and is
left on the specified branch at the most recent commit. The python and haskell sections of this code are identical except for the commands used to compile each:
`python -B` and `ghc -fno-code` respectively.

## Custom Feature

### Description

The file initializer creates a file as a template using user input for the author name and the organization with which he/she is affiliated, with the following headers:

1. Shebang line if applicable
2. Description field
3. Author name
4. Copyright information
5. Time and date the file was initiated with
6. HTML specific metadata

The script automates the time and date to UTC. Entering *'none'* when prompted for an organization associates the copyright to the author\'s name
The program then modifies the previous fields for any of the following different file formats:

Filetype | Items Included
---------|---------------
Python | shebang, desc., author, copyright, date
Haskell | shebang, desc., author, copyright, date
Bash | shebang, desc., author, copyright, date
Elm | desc., author, copyright, date
Javascript | shebang, desc., author, copyright, date
HTML | DOCTYPE, head, body, charset, desc., keywords, author, viewport, stylesheet 
CSS | desc., author, copyright, date
Other | desc., author, copyright, date

Any number of filenames may be entered separated by a space. The format is dictated by the extension of the filename entered.
The information is added into the file after a check to determine if the file exists already. All information is entered in block comments, with the exception of **other** having 
no distinct way of commenting and **HTML** being entered as metadata fields and a spot for a style file. The program continues to accept filenames for creation until the user
enters *'exit'* to stop the program.

More filetypes coming in a later version.
